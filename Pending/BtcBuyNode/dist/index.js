// Generated by LiveScript 1.6.0
(function(){
  var observer, cfg, apiKey, request, crypto, websocket, sendUrl, binanceSignedOption, binanceApiOption, observeAccount, local, symbol;
  observer = require('./observer');
  cfg = require('./config.json');
  apiKey = require('./private/binanceKey.json');
  request = require('request');
  crypto = require('crypto');
  websocket = require('websocket');
  sendUrl = curry$(function(opt, cb){
    var callback;
    callback = function(error, response, body){
      if (error) {
        return cb(error);
      } else {
        return cb(null, body);
      }
    };
    return request(opt, callback);
  });
  binanceSignedOption = function(url, data, method){
    var query, signature, opt;
    data.timestamp = new Date().getTime();
    data.recvWindow = 5000;
    query = Object.keys(data).reduce(function(a, k){
      return a.concat([k + "=" + encodeURIComponent(data[k])]);
    }, []).join("&");
    signature = crypto.createHmac('sha256', apiKey.SecretKey).update(query).digest('hex');
    return opt = {
      url: url + '?' + query + '&signature=' + signature,
      qs: data,
      method: method,
      timeout: 5000,
      headers: {
        'Content-type': "application/x-www-form-urlencoded",
        'X-MBX-APIKEY': apiKey.ApiKey
      }
    };
  };
  binanceApiOption = function(url, data, method){
    var query, opt;
    query = Object.keys(data).reduce(function(a, k){
      return a.concat([k + "=" + encodeURIComponent(data[k])]);
    }, []).join("&");
    return opt = {
      url: url + '?' + query,
      qs: data,
      method: method,
      timeout: 5000,
      headers: {
        'Content-type': "application/x-www-form-urlencoded",
        'X-MBX-APIKEY': apiKey.ApiKey
      }
    };
  };
  observeAccount = function(cb){
    return sendUrl(binanceApiOption("https://api.binance.com/api/v1/userDataStream", {}, "POST"), function(err, result){
      var listenKey, client;
      if (err) {
        return cb(err);
      }
      listenKey = JSON.parse(
      result).listenKey;
      client = new websocket.client();
      client.on('connectFailed', function(error){
        return console.log('Connect Error: ' + error.toString());
      });
      client.on('connect', function(connection){
        console.log('WebSocket Client Connected');
        connection.on('error', function(error){
          return console.log("Connection Error: " + error.toString());
        });
        connection.on('close', function(){
          return console.log('echo-protocol Connection Closed');
        });
        return connection.on('message', function(message){
          var data;
          if (message.type === 'utf8') {
            data = JSON.parse(message.utf8Data);
            console.log(data);
            return cb(null, data);
          }
        });
      });
      return client.connect("wss://stream.binance.com:9443/ws/" + listenKey);
    });
  };
  local = {
    orders: []
  };
  observeAccount(function(err, res){
    var evt, errCode, i$, ref$, len$, order, results$ = [];
    console.log(err, res);
    if (err) {
      return console.log(err);
    }
    evt = res.e, errCode = res.r;
    if (errCode !== "NONE") {
      return console.log(errCode);
    }
    switch (evt) {
    case "executionReport":
      for (i$ = 0, len$ = (ref$ = local.orders).length; i$ < len$; ++i$) {
        order = ref$[i$];
        results$.push(order.onReport(res));
      }
      return results$;
      break;
    default:

    }
  });
  symbol = "xrpbtc";
  sendUrl(binanceSignedOption("https://api.binance.com/api/v3/account", {}, "GET"), function(err, result){
    console.log(err, result);
    return sendUrl(binanceSignedOption("https://api.binance.com/api/v3/order/test", {
      symbol: symbol.toUpperCase(),
      side: "BUY",
      type: "MARKET",
      quantity: 1
    }, "POST"), function(err, result){
      console.log(err, result);
      return observer.observe(cfg, symbol, function(history){
        return sendUrl(binanceSignedOption("https://api.binance.com/api/v3/order/test", {
          symbol: symbol.toUpperCase(),
          side: "BUY",
          type: "MARKET",
          quantity: 1
        }, "POST"), function(err, result){
          return local.orders.push({
            info: result,
            onReport: function(arg$){
              var orderId, orderStatus, price, sellPrice;
              orderId = arg$.i, orderStatus = arg$.X, price = arg$.p;
              if (i === this.info.orderId && orderStatus === "FILLED") {
                sellPrice = p * cfg.earnRate;
                return sendUrl(binanceSignedOption("https://api.binance.com/api/v3/order/test", {
                  symbol: symbol.toUpperCase(),
                  side: "SELL",
                  type: "LIMIT",
                  quantity: 1,
                  price: sellPrice
                }, "POST"), function(err, result){});
              }
            }
          });
        });
      });
    });
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
