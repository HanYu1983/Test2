// Generated by LiveScript 1.6.0
(function(){
  var path, request, async, crypto, fs, file, fetch, testFetch, fetchStockData, formatStockData, Close, MA, RSV, KD;
  path = require('path');
  request = require('request');
  async = require('async');
  crypto = require('crypto');
  fs = require('fs');
  file = "./test.db";
  /*
  sqlite3 = require("sqlite3").verbose()
  db = new sqlite3.Database file
  
  db.serialize ->
      db.run "CREATE TABLE IF NOT EXISTS  Stuff (thing TEXT)"
      stmt = db.prepare "INSERT INTO Stuff VALUES (?)"
  
      for _, i in [0 to 10]
          stmt.run "staff_number#{i}"
      
      stmt.finalize()
      db.each "SELECT rowid AS id, thing FROM Stuff", (err, row)->
          console.log row.id + ": " + row.thing
  
  db.close()
  
  */
  fetch = curry$(function(url, dontUseCache, cb){
    var urlKey, path, ws;
    urlKey = crypto.createHash('md5').update(url).digest('hex');
    path = "cache/" + urlKey + ".html";
    if (!!dontUseCache === false && fs.existsSync(path)) {
      return fs.readFile(path, 'utf8', cb);
    } else {
      ws = fs.createWriteStream(path).on('error', cb).on('finish', function(){
        if (fs.existsSync(path) === false) {
          return cb('save lost');
        } else {
          return fs.readFile(path, 'utf8', cb);
        }
      });
      return request.get(url).on('error', cb).pipe(ws);
    }
  });
  testFetch = function(stockId, cnt){
    return async.series((function(){
      var i$, to$, results$ = [];
      for (i$ = 1, to$ = cnt; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()).map(function(m){
      return fetch("http://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&date=2017" + (m + '').padStart(2, '0') + "01&stockNo=" + stockId, false);
    }), function(err, results){
      if (err) {
        return console.log(err);
      } else {
        return console.log(results);
      }
    });
  };
  fetchStockData = function(stockId, years, months, cb){
    var urls, y, m;
    urls = Array.prototype.map.call((function(){
      var i$, ref$, len$, j$, ref1$, len1$, results$ = [];
      for (i$ = 0, len$ = (ref$ = years).length; i$ < len$; ++i$) {
        y = ref$[i$];
        for (j$ = 0, len1$ = (ref1$ = months).length; j$ < len1$; ++j$) {
          m = ref1$[j$];
          results$.push([y, m]);
        }
      }
      return results$;
    }()), function(arg$){
      var y, m;
      y = arg$[0], m = arg$[1];
      return "http://www.twse.com.tw/exchangeReport/STOCK_DAY?response=json&date=" + y + (m + '').padStart(2, '0') + "01&stockNo=" + stockId;
    });
    return async.series(urls.map(function(url){
      return fetch(url, false);
    }), function(err, results){
      return cb(err, results);
    });
  };
  formatStockData = function(data){
    var format;
    data = data.filter(function(r){
      return r.trim() !== "";
    }).map(JSON.parse).reduce(function(acc, arg$){
      var data;
      data = arg$.data;
      return acc.concat(data);
    }, []);
    format = function(arg$){
      var openTime, _, open, high, low, close, volumn;
      openTime = arg$[0], _ = arg$[1], _ = arg$[2], open = arg$[3], high = arg$[4], low = arg$[5], close = arg$[6], _ = arg$[7], volumn = arg$[8];
      return [new Date(openTime).toString()].concat([low, open, close, high, volumn].map(parseFloat));
    };
    return data.map(format);
  };
  Close = function(data){
    return data.map(function(arg$){
      var _, close;
      _ = arg$[0], _ = arg$[1], _ = arg$[2], close = arg$[3];
      return close;
    });
  };
  MA = function(data, cnt){
    var i$, ref$, len$, i, avg, results$ = [];
    for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
      i = ref$[i$];
      results$.push(avg = data.slice(i - (cnt - 1), i + 1).reduce(fn1$, 0) / cnt);
    }
    return results$;
    function fn$(){
      var i$, to$, results$ = [];
      for (i$ = cnt - 1, to$ = data.length; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }
    function fn1$(acc, curr){
      return acc + curr;
    }
  };
  RSV = function(data, cnt){
    var ret, res$, i$, ref$, len$, i, ref1$, openTime, low, open, close, high, before9k, min9k, max9k, rsv;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
      i = ref$[i$];
      ref1$ = data[i], openTime = ref1$[0], low = ref1$[1], open = ref1$[2], close = ref1$[3], high = ref1$[4];
      before9k = data.slice(i - (cnt - 1), i + 1);
      min9k = Math.min.apply(null, before9k.map(fn1$));
      max9k = Math.max.apply(null, before9k.map(fn2$));
      res$.push(rsv = (close - min9k) * 100 / (max9k - min9k));
    }
    ret = res$;
    return (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = cnt - 1; i$ < to$; ++i$) {
        results$.push(0);
      }
      return results$;
    }()).concat(ret);
    function fn$(){
      var i$, to$, results$ = [];
      for (i$ = cnt - 1, to$ = data.length; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }
    function fn1$(arg$){
      var _, low;
      _ = arg$[0], low = arg$[1];
      return low;
    }
    function fn2$(arg$){
      var _, high;
      _ = arg$[0], _ = arg$[1], _ = arg$[2], _ = arg$[3], high = arg$[4];
      return high;
    }
  };
  KD = function(data){
    var kline, dline, i$, ref$, len$, i, rsv, prevK, prevD, k, d;
    kline = [];
    dline = [];
    for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
      i = ref$[i$];
      rsv = data[i];
      prevK = i > 0 ? kline[i - 1] : 50;
      prevD = i > 0 ? dline[i - 1] : 50;
      k = prevK * (2 / 3) + rsv / 3;
      d = prevD * (2 / 3) + k / 3;
      kline.push(k);
      dline.push(d);
    }
    return [kline, dline];
    function fn$(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = data.length; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }
  };
  fetchStockData(2330, [2018], [1], function(err, data){
    if (err) {
      return console.log(err);
    }
    data = KD(
    RSV(formatStockData(data), 9));
    return console.log(data);
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
