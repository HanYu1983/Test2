// Generated by LiveScript 1.6.0
(function(){
  var request, crypto, moment, Tool, WebSocket, pako, signalR, zlib, ApiKey, WebSocketClient, baseurl, path, url, callbackPool, callbackSeq, sendAuth, sendPkg, client;
  request = require('request');
  crypto = require('crypto');
  moment = require('moment');
  Tool = require('./brickpicker/tool');
  WebSocket = require('ws');
  pako = require('pako');
  signalR = require('signalr-client');
  zlib = require('zlib');
  ApiKey = require('./private/apiKey');
  WebSocketClient = require('websocket').client;
  /*
  (err, res) <- Tool.getUrl Tool.huobiSignedOption("api.huobipro.com", "/v1/account/accounts", {}, "GET")
  console.log res
  
  info = JSON.parse(res)
  console.log info
  if info.status == "ok"
      account_id = info.data[0].id
      
      (err, res) <- Tool.getUrl Tool.huobiSignedOption("api.huobipro.com", "/v1/account/accounts/#{account_id}/balance", {}, "GET")
      console.log res
      
      (err, res) <- Tool.getUrl Tool.huobiSignedOption("api.huobipro.com", "/v1/order/orders/place", {"account-id": account_id, type: "buy-limit", amount: 1, symbol:"btcusdt", price: 1}, "POST")
      console.log res
  
  (err, res) <- Tool.getUrl Tool.huobiSignedOption("api.huobipro.com", "/v1/order/orders", {symbol:"btcusdt", states: "submitted,partial-filled"}, "GET")
  console.log res
  */
  baseurl = "api.huobi.com";
  path = "/ws/v1";
  url = "wss://" + baseurl + path;
  console.log(url);
  callbackPool = {};
  callbackSeq = 0;
  sendAuth = function(connection, cb){
    var method, data, p, meta, hash, signature, pkg, k, v, sendData;
    method = "GET";
    data = {
      AccessKeyId: ApiKey.huobi.AccessKey,
      SignatureMethod: "HmacSHA256",
      SignatureVersion: "2",
      Timestamp: moment.utc().format('YYYY-MM-DDTHH:mm:ss')
    };
    p = Object.keys(data).reduce(function(a, k){
      return a.concat([k + "=" + encodeURIComponent(data[k])]);
    }, []).sort().join("&");
    meta = [method, baseurl, path, p].join('\n');
    hash = crypto.createHmac('sha256', ApiKey.huobi.SecretKey).update(meta).digest('base64');
    signature = hash;
    data.Signature = signature;
    pkg = {
      op: "auth",
      cid: callbackSeq++
    };
    for (k in data) {
      v = data[k];
      pkg[k] = v;
    }
    sendData = JSON.stringify(pkg);
    connection.sendUTF(sendData);
    return callbackPool[pkg.cid] = cb;
  };
  sendPkg = function(connection, pkg, cb){
    var sendData;
    if (pkg.op !== "sub") {
      pkg.cid = callbackSeq++;
      callbackPool[pkg.cid] = cb;
    }
    sendData = JSON.stringify(pkg);
    return connection.sendUTF(sendData);
  };
  client = new WebSocketClient();
  client.on('connectFailed', function(error){
    return console.log('Connect Error: ' + error.toString());
  });
  client.on('connect', function(connection){
    console.log('WebSocket Client Connected');
    connection.on('error', function(error){
      return console.log("Connection Error: " + error.toString());
    });
    connection.on('close', function(){
      return console.log('echo-protocol Connection Closed');
    });
    connection.on('message', function(message){
      var res, op, cid, data, ref$;
      if (deepEq$(message.type, 'binary', '===')) {
        res = JSON.parse(pako.inflate(message.binaryData, {
          to: 'string'
        }));
        console.log(res);
        op = res.op, cid = res.cid, data = res.data;
        if (op !== "sub" && callbackPool.hasOwnProperty(cid)) {
          callbackPool[cid](res);
          return ref$ = callbackPool[cid], delete callbackPool[cid], ref$;
        }
      }
    });
    return sendAuth(connection, function(data){
      console.log(data);
      sendPkg(connection, {
        op: "sub",
        topic: "accounts"
      });
      return sendPkg(connection, {
        op: "sub",
        topic: "orders.btcusdt"
      });
    });
  });
  client.connect(url);
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) {
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
